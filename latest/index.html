<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#Server-/-Handlers-1">Server / Handlers</a></li><li><a class="toctext" href="#HTTP-Types-1">HTTP Types</a></li><li><a class="toctext" href="#HTTP-Utilities-1">HTTP Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> provides a pure Julia library for HTTP functionality.</p><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#Server-/-Handlers-1">Server / Handlers</a></li><li><a href="index.html#HTTP-Types-1">HTTP Types</a></li><li><a href="index.html#HTTP-Utilities-1">HTTP Utilities</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><p>Note that the HTTP methods of POST, DELETE, PUT, etc. all follow the same format as <code>HTTP.get</code>, documented below.</p><pre><code class="language-none">HTTP.get
HTTP.request
HTTP.Client
HTTP.Connection</code></pre><h2><a class="nav-anchor" id="Server-/-Handlers-1" href="#Server-/-Handlers-1">Server / Handlers</a></h2><pre><code class="language-none">HTTP.serve
HTTP.Server
HTTP.Handler
HTTP.HandlerFunction
HTTP.Router
HTTP.register!
HTTP.FourOhFour</code></pre><h2><a class="nav-anchor" id="HTTP-Types-1" href="#HTTP-Types-1">HTTP Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.URI" href="#HTTP.URIs.URI"><code>HTTP.URIs.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URI(host; userinfo=&quot;&quot;, path=&quot;&quot;, query=&quot;&quot;, fragment=&quot;&quot;, isconnect=false)
HTTP.URI(; scheme=&quot;&quot;, hostname=&quot;&quot;, port=&quot;&quot;, ...)
parse(HTTP.URI, str::String; isconnect=false)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>For efficiency, the internal representation is stored as a set of offsets and lengths to the various uri components. To access and return these components as strings, use the various accessor methods:</p><ul><li><p><code>HTTP.scheme</code>: returns the scheme (if any) associated with the uri</p></li><li><p><code>HTTP.userinfo</code>: returns the userinfo (if any) associated with the uri</p></li><li><p><code>HTTP.hostname</code>: returns the hostname only of the uri</p></li><li><p><code>HTTP.port</code>: returns the port of the uri; will return &quot;80&quot; or &quot;443&quot; by default if the scheme is &quot;http&quot; or &quot;https&quot;, respectively</p></li><li><p><code>HTTP.host</code>: returns the &quot;hostname:port&quot; combination</p></li><li><p><code>HTTP.path</code>: returns the path for a uri</p></li><li><p><code>HTTP.query</code>: returns the query for a uri</p></li><li><p><code>HTTP.fragment</code>: returns the fragment for a uri</p></li><li><p><code>HTTP.resource</code>: returns the path-query-fragment combination</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/uri.jl#L20-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Request" href="#HTTP.Request"><code>HTTP.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request()
Request(method, uri, headers, body; options=RequestOptions())
Request(; method=HTTP.GET, uri=HTTP.URI(&quot;&quot;), major=1, minor=1, headers=HTTP.Headers(), body=&quot;&quot;)</code></pre><p>A type representing an http request. <code>method</code> can be provided as a string or <code>HTTP.GET</code> type enum. <code>uri</code> can be provided as an actual <code>HTTP.URI</code> or string. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> may be provided as string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>. <code>options</code> should be a <code>RequestOptions</code> type, see <code>?HTTP.RequestOptions</code> for details.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.method</code>: method for a request</p></li><li><p><code>HTTP.major</code>: major http version for a request</p></li><li><p><code>HTTP.minor</code>: minor http version for a request</p></li><li><p><code>HTTP.uri</code>: uri for a request</p></li><li><p><code>HTTP.headers</code>: headers for a request</p></li><li><p><code>HTTP.body</code>: body for a request as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a request body:</p><ul><li><p><code>take!(r)</code>: consume the request body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(r)</code>: consume the request body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/types.jl#L87-L108">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RequestOptions" href="#HTTP.RequestOptions"><code>HTTP.RequestOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RequestOptions(; chunksize=, connecttimeout=, readtimeout=, tlsconfig=, maxredirects=, allowredirects=)</code></pre><p>A type to represent various http request options. Lives as a separate type so that options can be set at the <code>HTTP.Client</code> level to be applied to every request sent. Options include:</p><ul><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li><li><p><code>managecookies::Bool</code>: whether the request client should automatically store and add cookies from/to requests (following appropriate host-specific &amp; expiration rules)</p></li><li><p><code>statusraise::Bool</code>: whether an <code>HTTP.StatusError</code> should be raised on a non-2XX response status code</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/types.jl#L23-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Response" href="#HTTP.Response"><code>HTTP.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response(status::Integer)
Response(status::Integer, body::String)
Response(status::Integer, headers, body)
Response(; status=200, cookies=HTTP.Cookie[], headers=HTTP.Headers(), body=&quot;&quot;)</code></pre><p>A type representing an http response. <code>status</code> represents the http status code for the response. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> can be provided as a string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.status</code>: status for a response</p></li><li><p><code>HTTP.statustext</code>: statustext for a response</p></li><li><p><code>HTTP.major</code>: major http version for a response</p></li><li><p><code>HTTP.minor</code>: minor http version for a response</p></li><li><p><code>HTTP.cookies</code>: cookies for a response, returned as a <code>Vector{HTTP.Cookie}</code></p></li><li><p><code>HTTP.headers</code>: headers for a response</p></li><li><p><code>HTTP.request</code>: the <code>HTTP.Request</code> that resulted in this response</p></li><li><p><code>HTTP.history</code>: history for a response if redirects were followed from an original request</p></li><li><p><code>HTTP.body</code>: body for a response as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a response body:</p><ul><li><p><code>take!(r)</code>: consume the response body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(r)</code>: consume the response body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/types.jl#L182-L205">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/cookies.jl#L38-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.FIFOBuffers.FIFOBuffer" href="#HTTP.FIFOBuffers.FIFOBuffer"><code>HTTP.FIFOBuffers.FIFOBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FIFOBuffer([max::Integer])
FIFOBuffer(string_or_bytes_vector)
FIFOBuffer(io::IO)</code></pre><p>A <code>FIFOBuffer</code> is a first-in, first-out, in-memory, async-friendly IO buffer type.</p><p><code>FIFOBuffer([max])</code>: creates a &quot;open&quot; <code>FIFOBuffer</code> with a maximum size of <code>max</code>; this means that bytes can be written up until <code>max</code> number of bytes have been written (with none being read). At this point, the <code>FIFOBuffer</code> is full and will return 0 for all subsequent writes. If no <code>max</code> (<code>FIFOBuffer()</code>) argument is given, then a default size of <code>typemax(Int32)^2</code> is used; this essentially allows all writes every time. Note that providing a string or byte vector argument mirrors the behavior of <code>Base.IOBuffer</code> in that the <code>max</code> size of the <code>FIFOBuffer</code> is the length of the string/byte vector; it is also not writeable.</p><p>Reading is supported via <code>readavailable(f)</code> and <code>read(f, nb)</code>, which returns all or <code>nb</code> bytes, respectively, starting at the earliest bytes written. All read functions will return an empty byte vector, even if the buffer has been closed. Checking <code>eof</code> will correctly reflect when the buffer has been closed and no more bytes will be available for reading.</p><p>You may call <code>String(f::FIFOBuffer)</code> to view the current contents in the buffer without consuming them.</p><p>A <code>FIFOBuffer</code> is built to be used asynchronously to allow buffered reading and writing. In particular, a <code>FIFOBuffer</code> detects if it is being read from/written to the main task, or asynchronously, and will behave slightly differently depending on which.</p><p>Specifically, when reading from a <code>FIFOBuffer</code>, if accessed from the main task, it will not block if there are no bytes available to read, instead returning an empty <code>UInt8[]</code>. If being read from asynchronously, however, reading will block until additional bytes have been written. An example of this in action is:</p><pre><code class="language-julia">f = HTTP.FIFOBuffer(5) # create a FIFOBuffer that will hold at most 5 bytes, currently empty
f2 = HTTP.FIFOBuffer(5) # a 2nd buffer that we&#39;ll write to asynchronously

# start an asynchronous writing task with the 2nd buffer
tsk = @async begin
    while !eof(f)
        write(f2, readavailable(f))
    end
end

# now write some bytes to the first buffer
# writing triggers our async task to wake up and read the bytes we just wrote
# leaving the first buffer empty again and blocking again until more bytes have been written
write(f, [0x01, 0x02, 0x03, 0x04, 0x05])

# we can see that `f2` now holds the bytes we wrote to `f`
String(readavailable(f2))

# our async task will continue until `f` is closed
close(f)

istaskdone(tsk) # true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/fifobuffer.jl#L7-L56">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Utilities-1" href="#HTTP-Utilities-1">HTTP Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.parse" href="#HTTP.parse"><code>HTTP.parse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.parse([HTTP.Request, HTTP.Response], str; kwargs...)</code></pre><p>Parse a <code>HTTP.Request</code> or <code>HTTP.Response</code> from a string. <code>str</code> must contain at least one full request or response (but may include more than one). Supported keyword arguments include:</p><ul><li><p><code>extra</code>: a <code>Ref{String}</code> that will be used to store any extra bytes beyond a full request or response</p></li><li><p><code>lenient</code>: whether the request/response parsing should allow additional characters</p></li><li><p><code>maxuri</code>: the maximum allowed size of a uri in a request</p></li><li><p><code>maxheader</code>: the maximum allowed size of headers</p></li><li><p><code>maxbody</code>: the maximum allowed size of a request or response body</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/parser.jl#L127-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.escape" href="#HTTP.URIs.escape"><code>HTTP.URIs.escape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>percent-encode a string, dict, or pair for a uri</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/uri.jl#L163">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.unescape" href="#HTTP.URIs.unescape"><code>HTTP.URIs.unescape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>unescape a percent-encoded uri/url</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/uri.jl#L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.splitpath" href="#HTTP.URIs.splitpath"><code>HTTP.URIs.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/uri.jl#L195-L198">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid" href="#Base.isvalid"><code>Base.isvalid</code></a> — <span class="docstring-category">Function</span>.</div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/uri.jl#L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/sniff.jl#L21-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.escapeHTML" href="#HTTP.escapeHTML"><code>HTTP.escapeHTML</code></a> — <span class="docstring-category">Function</span>.</div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/bd04aecaecfe735176fb57e506fbb0cc9211d7cd/src/utils.jl#L1-L5">source</a><br/></section><footer><hr/></footer></article></body></html>
