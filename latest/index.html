<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#Server-/-Handlers-1">Server / Handlers</a></li><li><a class="toctext" href="#HTTP-Types-1">HTTP Types</a></li><li><a class="toctext" href="#HTTP-Utilities-1">HTTP Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> provides a pure Julia library for HTTP functionality.</p><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#Server-/-Handlers-1">Server / Handlers</a></li><li><a href="index.html#HTTP-Types-1">HTTP Types</a></li><li><a href="index.html#HTTP-Utilities-1">HTTP Utilities</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><p>Note that the HTTP methods of POST, DELETE, PUT, etc. all follow the same format as <code>HTTP.get</code>, documented below.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.get(uri; kwargs...) -&gt; Response
HTTP.get(client::HTTP.Client, uri; kwargs...) -&gt; Response</code></pre><p>Build and execute an http &quot;GET&quot; request. Query parameters can be passed via the <code>query</code> keyword argument as a <code>Dict</code>. Multiple query parameters with the same key can be passed like <code>Dict(&quot;key1&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;], &quot;key2&quot;=&gt;...)</code>. Returns a <code>Response</code> object that includes the resulting status code (<code>HTTP.status(r)</code> and <code>HTTP.statustext(r)</code>), response headers (<code>HTTP.headers(r)</code>), cookies (<code>HTTP.cookies(r)</code>), response history if redirects were involved (<code>HTTP.history(r)</code>), and response body (<code>HTTP.body(r)</code> or <code>String(r)</code> or <code>take!(r)</code>).</p><p>The body or payload for a request can be given through the <code>body</code> keyword arugment. The body can be given as a <code>String</code>, <code>Vector{UInt8}</code>, <code>IO</code>, <code>HTTP.FIFOBuffer</code> or <code>Dict</code> argument type. See examples below for how to use an <code>HTTP.FIFOBuffer</code> for asynchronous streaming uploads.</p><p>If the body is provided as a <code>Dict</code>, the request body will be uploaded using the multipart/form-data encoding. The key-value pairs in the Dict will constitute the name and value of each multipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an <code>IOStream</code> such as returned via <code>open(file)</code>, an <code>IOBuffer</code> for in-memory data, or even an <code>HTTP.FIFOBuffer</code>. For complete control over the multipart details, an <code>HTTP.Multipart</code> type is provided to support setting the <code>Content-Type</code>, <code>filename</code>, and <code>Content-Transfer-Encoding</code> if desired. See <code>?HTTP.Multipart</code> for more details.</p><p>Additional keyword arguments supported, include:</p><ul><li><p><code>headers::Dict{String,String}</code>: headers given as Dict to be sent with the request</p></li><li><p><code>body</code>: a request body can be given as a <code>String</code>, <code>Vector{UInt8}</code>, <code>IO</code>, <code>HTTP.FIFOBuffer</code> or <code>Dict</code>; see example below for how to utilize <code>HTTP.FIFOBuffer</code> for &quot;streaming&quot; request bodies; a <code>Dict</code> argument will be converted to a multipart form upload</p></li><li><p><code>stream::Bool=false</code>: enable response body streaming; depending on the response body size, the request will return before the full body has been received; as the response body is read, additional bytes will be recieved and put in the response body. Readers should read until <code>eof(response.body) == true</code>; see below for an example of response streaming</p></li><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li><li><p><code>managecookies::Bool</code>: whether the request client should automatically store and add cookies from/to requests (following appropriate host-specific &amp; expiration rules)</p></li><li><p><code>statusraise::Bool</code>: whether an <code>HTTP.StatusError</code> should be raised on a non-2XX response status code</p></li></ul><p>Simple request example:</p><pre><code class="language-julia">julia&gt; resp = HTTP.get(&quot;http://httpbin.org/ip&quot;)
HTTP.Response:
&quot;&quot;&quot;
HTTP/1.1 200 OK
Connection: keep-alive
X-Powered-By: Flask
Content-Length: 32
Via: 1.1 vegur
Access-Control-Allow-Credentials: true
X-Processed-Time: 0.000903129577637
Date: Wed, 23 Aug 2017 23:35:59 GMT
Content-Type: application/json
Access-Control-Allow-Origin: *
Server: meinheld/0.6.1
Content-Length: 32

{ 
  &quot;origin&quot;: &quot;50.207.241.62&quot;
}
&quot;&quot;&quot;


julia&gt; String(resp)
&quot;{
  &quot;origin&quot;: &quot;65.130.216.45&quot;
}
&quot;</code></pre><p>Response streaming example (asynchronous download):</p><pre><code class="language-julia">julia&gt; r = HTTP.get(&quot;http://httpbin.org/stream/100&quot;; stream=true)
HTTP.Response:
&quot;&quot;&quot;
HTTP/1.1 200 OK
Connection: keep-alive
X-Powered-By: Flask
Transfer-Encoding: chunked
Via: 1.1 vegur
Access-Control-Allow-Credentials: true
X-Processed-Time: 0.000981092453003
Date: Wed, 23 Aug 2017 23:36:56 GMT
Content-Type: application/json
Access-Control-Allow-Origin: *
Server: meinheld/0.6.1

[HTTP.Response body of 27415 bytes]
Content-Length: 27390

{&quot;id&quot;: 0, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8,application/json&quot;}}
{&quot;id&quot;: 1, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8,application/json&quot;}}
{&quot;id&quot;: 2, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;
⋮</code></pre><p>&quot;&quot;&quot;</p><p>julia&gt; body = HTTP.body(r) HTTP.FIFOBuffers.FIFOBuffer(27390, 1048576, 27390, 1, 27391, -1, 27390, UInt8[0x7b, 0x22, 0x69, 0x64, 0x22, 0x3a, 0x20, 0x30, 0x2c, 0x20  …  0x6e, 0x2f, 0x6a, 0x73, 0x6f, 0x6e, 0x22, 0x7d, 0x7d, 0x0a], Condition(Any[]), Task (done) @0x0000000112d84250, true)</p><p>julia&gt; while true            println(String(readavailable(body)))            eof(body) &amp;&amp; break        end {&quot;id&quot;: 0, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8,application/json&quot;}} {&quot;id&quot;: 1, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8,application/json&quot;}} {&quot;id&quot;: 2, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8,application/json&quot;}} {&quot;id&quot;: 3, &quot;origin&quot;: &quot;50.207.241.62&quot;, &quot;args&quot;: {}, &quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Connection&quot;: &quot;close&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8,application/json&quot;}} ...</p><pre><code class="language-none">
Request streaming example (asynchronous upload):</code></pre><p>julia</p><p><strong>create a FIFOBuffer for sending our request body</strong></p><p>f = HTTP.FIFOBuffer()</p><p><strong>write initial data</strong></p><p>write(f, &quot;hey&quot;)</p><p><strong>start an HTTP.post asynchronously</strong></p><p>t = @async HTTP.post(&quot;http://httpbin.org/post&quot;; body=f) write(f, &quot; there &quot;) # as we write to f, it triggers another chunk to be sent in our async request write(f, &quot;sailor&quot;) close(f) # setting eof on f causes the async request to send a final chunk and return the response</p><p>resp = wait(t) # get our response by getting the result of our asynchronous task ```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/client.jl#L374-L496">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Client" href="#HTTP.Client"><code>HTTP.Client</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.Client([logger::IO]; args...)</code></pre><p>A type to facilitate connections to remote hosts, send HTTP requests, and manage state between requests. Takes an optional <code>logger</code> IO argument where client activity is recorded (defaults to <code>STDOUT</code>). Additional keyword arguments can be passed that will get transmitted with each HTTP request:</p><ul><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li><li><p><code>managecookies::Bool</code>: whether the request client should automatically store and add cookies from/to requests (following appropriate host-specific &amp; expiration rules)</p></li><li><p><code>statusraise::Bool</code>: whether an <code>HTTP.StatusError</code> should be raised on a non-2XX response status code</p></li><li><p><code>insecure::Bool</code>: whether an &quot;https&quot; connection should allow insecure connections (no TLS verification); default = <code>false</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/client.jl#L22-L40">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Connection" href="#HTTP.Connection"><code>HTTP.Connection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.Connection</code></pre><p>Represents a persistent client connection to a remote host; only created when a server response includes the &quot;Connection: keep-alive&quot; header. An open and non-idle connection will be reused when sending subsequent requests to the same host.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/client.jl#L3-L9">source</a><br/></section><h2><a class="nav-anchor" id="Server-/-Handlers-1" href="#Server-/-Handlers-1">Server / Handlers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Nitrogen.serve" href="#HTTP.Nitrogen.serve"><code>HTTP.Nitrogen.serve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.serve([server,] host::IPAddr, port::Int; verbose::Bool=true, kwargs...)</code></pre><p>Start a server listening on the provided <code>host</code> and <code>port</code>. <code>verbose</code> indicates whether server activity should be logged. Optional keyword arguments allow construction of <code>Server</code> on the fly if the <code>server</code> argument isn&#39;t provided directly. See <code>?HTTP.Server</code> for more details on server construction and supported keyword arguments. By default, <code>HTTP.serve</code> aims to &quot;never die&quot;, catching and recovering from all internal errors. Two methods for stopping <code>HTTP.serve</code> include interrupting (ctrl/cmd+c) if blocking on the main task, or sending the kill signal via the server&#39;s in channel (<code>put!(server.in, HTTP.KILL)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/server.jl#L306-L315">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Nitrogen.Server" href="#HTTP.Nitrogen.Server"><code>HTTP.Nitrogen.Server</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Server(handler, logger::IO=STDOUT; kwargs...)</code></pre><p>An http/https server. Supports listening on a <code>host</code> and <code>port</code> via the <code>HTTP.serve(server, host, port)</code> function. <code>handler</code> is a function of the form <code>f(::Request, ::Response) -&gt; HTTP.Response</code>, i.e. it takes both a <code>Request</code> and pre-built <code>Response</code> objects as inputs and returns the, potentially modified, <code>Response</code>. <code>logger</code> indicates where logging output should be directed. When <code>HTTP.serve</code> is called, it aims to &quot;never die&quot;, catching and recovering from all internal errors. To forcefully stop, one can obviously kill the julia process, interrupt (ctrl/cmd+c) if main task, or send the kill signal over a server in channel like: <code>put!(server.in, HTTP.KILL)</code>.</p><p>Supported keyword arguments include:</p><ul><li><p><code>cert</code>: if https, the cert file to use, as passed to <code>HTTP.TLS.SSLConfig(cert, key)</code></p></li><li><p><code>key</code>: if https, the key file to use, as passed to <code>HTTP.TLS.SSLConfig(cert, key)</code></p></li><li><p><code>tlsconfig</code>: pass in an already-constructed <code>HTTP.TLS.SSLConfig</code> instance</p></li><li><p><code>readtimeout</code>: how long a client connection will be left open without receiving any bytes</p></li><li><p><code>ratelimit</code>: a <code>Rational{Int}</code> of the form <code>5//1</code> indicating how many <code>messages//second</code> should be allowed per client IP address; requests exceeding the rate limit will be dropped</p></li><li><p><code>maxuri</code>: the maximum size in bytes that a request uri can be; default 8000</p></li><li><p><code>maxheader</code>: the maximum size in bytes that request headers can be; default 8kb</p></li><li><p><code>maxbody</code>: the maximum size in bytes that a request body can be; default 4gb</p></li><li><p><code>support100continue</code>: a <code>Bool</code> indicating whether <code>Expect: 100-continue</code> headers should be supported for delayed request body sending; default = <code>true</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/server.jl#L55-L75">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Handler" href="#HTTP.Handlers.Handler"><code>HTTP.Handlers.Handler</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract type representing an object that knows how to &quot;handle&quot; a server request.</p><p>Types of handlers include <code>HandlerFunction</code> (a julia function of the form <code>f(request, response</code>) and <code>Router</code> (which pattern matches request url paths to other specific <code>Handler</code> types).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/handlers.jl#L24-L29">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.HandlerFunction" href="#HTTP.Handlers.HandlerFunction"><code>HTTP.Handlers.HandlerFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><p>HandlerFunction(f::Function)</p><p>A Function-wrapper type that is a subtype of <code>Handler</code>. Takes a single Function as an argument. The provided argument should be of the form <code>f(request, response) =&gt; Response</code>, i.e. it accepts both a <code>Request</code> and <code>Response</code> and returns a <code>Response</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/handlers.jl#L32-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Router" href="#HTTP.Handlers.Router"><code>HTTP.Handlers.Router</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Router(h::Handler) Router(f::Function) Router()</p><p>An <code>HTTP.Handler</code> type that supports mapping request url paths to other <code>HTTP.Handler</code> types. Can accept a default <code>Handler</code> or <code>Function</code> that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via <code>HTTP.register!(r::Router, path, handler)</code>, see <code>?HTTP.register!</code> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/handlers.jl#L48-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.register!" href="#HTTP.Handlers.register!"><code>HTTP.Handlers.register!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>HTTP.register!(r::Router, url, handler) HTTP.register!(r::Router, m::Union{Method, String}, url, handler)</p><p>Function to map request urls matching <code>url</code> and an optional method <code>m</code> to another <code>handler::HTTP.Handler</code>. URLs are registered one at a time, and multiple urls can map to the same handler. Methods can be passed as a string <code>&quot;GET&quot;</code> or enum object directly <code>HTTP.GET</code>. The URL can be passed as a String or <code>HTTP.URI</code> object directly. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:</p><ul><li><p><code>&quot;http://*&quot;</code>: match all HTTP requests, regardless of path</p></li><li><p><code>&quot;https://*&quot;</code>: match all HTTPS requests, regardless of path</p></li><li><p><code>&quot;google&quot;</code>: regardless of scheme, match requests to the hostname &quot;google&quot;</p></li><li><p><code>&quot;google/gmail&quot;</code>: match requests to hostname &quot;google&quot;, and path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail&quot;</code>: regardless of scheme or host, match any request with a path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail/userId/*/inbox</code>: match any request matching the path pattern, &quot;*&quot; is used as a wildcard that matches any value between the two &quot;/&quot;</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/handlers.jl#L81-L98">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Types-1" href="#HTTP-Types-1">HTTP Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.URI" href="#HTTP.URIs.URI"><code>HTTP.URIs.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URL(host; userinfo=&quot;&quot;, path=&quot;&quot;, query=&quot;&quot;, fragment=&quot;&quot;, isconnect=false)
HTTP.URI(; scheme=&quot;&quot;, hostname=&quot;&quot;, port=&quot;&quot;, ...)
HTTP.URI(str; isconnect=false)
parse(HTTP.URI, str::String; isconnect=false)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>For efficiency, the internal representation is stored as a set of offsets and lengths to the various uri components. To access and return these components as strings, use the various accessor methods:</p><ul><li><p><code>HTTP.scheme</code>: returns the scheme (if any) associated with the uri</p></li><li><p><code>HTTP.userinfo</code>: returns the userinfo (if any) associated with the uri</p></li><li><p><code>HTTP.hostname</code>: returns the hostname only of the uri</p></li><li><p><code>HTTP.port</code>: returns the port of the uri; will return &quot;80&quot; or &quot;443&quot; by default if the scheme is &quot;http&quot; or &quot;https&quot;, respectively</p></li><li><p><code>HTTP.host</code>: returns the &quot;hostname:port&quot; combination</p></li><li><p><code>HTTP.path</code>: returns the path for a uri</p></li><li><p><code>HTTP.query</code>: returns the query for a uri</p></li><li><p><code>HTTP.fragment</code>: returns the fragment for a uri</p></li><li><p><code>HTTP.resource</code>: returns the path-query-fragment combination</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/uri.jl#L19-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Request" href="#HTTP.Request"><code>HTTP.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request()
Request(method, uri, headers, body; options=RequestOptions())
Request(; method=HTTP.GET, uri=HTTP.URI(&quot;&quot;), major=1, minor=1, headers=HTTP.Headers(), body=&quot;&quot;)</code></pre><p>A type representing an http request. <code>method</code> can be provided as a string or <code>HTTP.GET</code> type enum. <code>uri</code> can be provided as an actual <code>HTTP.URI</code> or string. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> may be provided as string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>. <code>options</code> should be a <code>RequestOptions</code> type, see <code>?HTTP.RequestOptions</code> for details.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.method</code>: method for a request</p></li><li><p><code>HTTP.major</code>: major http version for a request</p></li><li><p><code>HTTP.minor</code>: minor http version for a request</p></li><li><p><code>HTTP.uri</code>: uri for a request</p></li><li><p><code>HTTP.headers</code>: headers for a request</p></li><li><p><code>HTTP.body</code>: body for a request as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a request body:</p><ul><li><p><code>take!(r)</code>: consume the request body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(r)</code>: consume the request body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/types.jl#L90-L111">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RequestOptions" href="#HTTP.RequestOptions"><code>HTTP.RequestOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RequestOptions(; chunksize=, connecttimeout=, readtimeout=, tlsconfig=, maxredirects=, allowredirects=)</code></pre><p>A type to represent various http request options. Lives as a separate type so that options can be set at the <code>HTTP.Client</code> level to be applied to every request sent. Options include:</p><ul><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li><li><p><code>managecookies::Bool</code>: whether the request client should automatically store and add cookies from/to requests (following appropriate host-specific &amp; expiration rules)</p></li><li><p><code>statusraise::Bool</code>: whether an <code>HTTP.StatusError</code> should be raised on a non-2XX response status code</p></li><li><p><code>insecure::Bool</code>: whether an &quot;https&quot; connection should allow insecure connections (no TLS verification); default = <code>false</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/types.jl#L23-L40">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Response" href="#HTTP.Response"><code>HTTP.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response(status::Integer)
Response(status::Integer, body::String)
Response(status::Integer, headers, body)
Response(; status=200, cookies=HTTP.Cookie[], headers=HTTP.Headers(), body=&quot;&quot;)</code></pre><p>A type representing an http response. <code>status</code> represents the http status code for the response. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> can be provided as a string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.status</code>: status for a response</p></li><li><p><code>HTTP.statustext</code>: statustext for a response</p></li><li><p><code>HTTP.major</code>: major http version for a response</p></li><li><p><code>HTTP.minor</code>: minor http version for a response</p></li><li><p><code>HTTP.cookies</code>: cookies for a response, returned as a <code>Vector{HTTP.Cookie}</code></p></li><li><p><code>HTTP.headers</code>: headers for a response</p></li><li><p><code>HTTP.request</code>: the <code>HTTP.Request</code> that resulted in this response</p></li><li><p><code>HTTP.history</code>: history for a response if redirects were followed from an original request</p></li><li><p><code>HTTP.body</code>: body for a response as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a response body:</p><ul><li><p><code>take!(r)</code>: consume the response body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(r)</code>: consume the response body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/types.jl#L185-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/cookies.jl#L38-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.FIFOBuffers.FIFOBuffer" href="#HTTP.FIFOBuffers.FIFOBuffer"><code>HTTP.FIFOBuffers.FIFOBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FIFOBuffer([max::Integer])
FIFOBuffer(string_or_bytes_vector)
FIFOBuffer(io::IO)</code></pre><p>A <code>FIFOBuffer</code> is a first-in, first-out, in-memory, async-friendly IO buffer type.</p><p><code>FIFOBuffer([max])</code>: creates a &quot;open&quot; <code>FIFOBuffer</code> with a maximum size of <code>max</code>; this means that bytes can be written up until <code>max</code> number of bytes have been written (with none being read). At this point, the <code>FIFOBuffer</code> is full and will return 0 for all subsequent writes. If no <code>max</code> (<code>FIFOBuffer()</code>) argument is given, then a default size of <code>typemax(Int32)^2</code> is used; this essentially allows all writes every time. Note that providing a string or byte vector argument mirrors the behavior of <code>Base.IOBuffer</code> in that the <code>max</code> size of the <code>FIFOBuffer</code> is the length of the string/byte vector; it is also not writeable.</p><p>Reading is supported via <code>readavailable(f)</code> and <code>read(f, nb)</code>, which returns all or <code>nb</code> bytes, respectively, starting at the earliest bytes written. All read functions will return an empty byte vector, even if the buffer has been closed. Checking <code>eof</code> will correctly reflect when the buffer has been closed and no more bytes will be available for reading.</p><p>You may call <code>String(f::FIFOBuffer)</code> to view the current contents in the buffer without consuming them.</p><p>A <code>FIFOBuffer</code> is built to be used asynchronously to allow buffered reading and writing. In particular, a <code>FIFOBuffer</code> detects if it is being read from/written to the main task, or asynchronously, and will behave slightly differently depending on which.</p><p>Specifically, when reading from a <code>FIFOBuffer</code>, if accessed from the main task, it will not block if there are no bytes available to read, instead returning an empty <code>UInt8[]</code>. If being read from asynchronously, however, reading will block until additional bytes have been written. An example of this in action is:</p><pre><code class="language-julia">f = HTTP.FIFOBuffer(5) # create a FIFOBuffer that will hold at most 5 bytes, currently empty
f2 = HTTP.FIFOBuffer(5) # a 2nd buffer that we&#39;ll write to asynchronously

# start an asynchronous writing task with the 2nd buffer
tsk = @async begin
    while !eof(f)
        write(f2, readavailable(f))
    end
end

# now write some bytes to the first buffer
# writing triggers our async task to wake up and read the bytes we just wrote
# leaving the first buffer empty again and blocking again until more bytes have been written
write(f, [0x01, 0x02, 0x03, 0x04, 0x05])

# we can see that `f2` now holds the bytes we wrote to `f`
String(readavailable(f2))

# our async task will continue until `f` is closed
close(f)

istaskdone(tsk) # true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/fifobuffer.jl#L7-L56">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Utilities-1" href="#HTTP-Utilities-1">HTTP Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.parse" href="#HTTP.parse"><code>HTTP.parse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.parse([HTTP.Request, HTTP.Response], str; kwargs...)</code></pre><p>Parse a <code>HTTP.Request</code> or <code>HTTP.Response</code> from a string. <code>str</code> must contain at least one full request or response (but may include more than one). Supported keyword arguments include:</p><ul><li><p><code>extra</code>: a <code>Ref{String}</code> that will be used to store any extra bytes beyond a full request or response</p></li><li><p><code>lenient</code>: whether the request/response parsing should allow additional characters</p></li><li><p><code>maxuri</code>: the maximum allowed size of a uri in a request</p></li><li><p><code>maxheader</code>: the maximum allowed size of headers</p></li><li><p><code>maxbody</code>: the maximum allowed size of a request or response body</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/parser.jl#L127-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.escape" href="#HTTP.URIs.escape"><code>HTTP.URIs.escape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>percent-encode a string, dict, or pair for a uri</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/uri.jl#L167">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.unescape" href="#HTTP.URIs.unescape"><code>HTTP.URIs.unescape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>unescape a percent-encoded uri/url</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/uri.jl#L182">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.splitpath" href="#HTTP.URIs.splitpath"><code>HTTP.URIs.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/uri.jl#L199-L202">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid" href="#Base.isvalid"><code>Base.isvalid</code></a> — <span class="docstring-category">Function</span>.</div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/uri.jl#L146">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/sniff.jl#L21-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.escapeHTML" href="#HTTP.escapeHTML"><code>HTTP.escapeHTML</code></a> — <span class="docstring-category">Function</span>.</div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/4b7a5b8cc33047efa2174b439a2c7ef1ef132251/src/utils.jl#L1-L5">source</a><br/></section><footer><hr/></footer></article></body></html>
