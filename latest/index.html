<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>HTTP.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#HTTP-Types-1">HTTP Types</a></li><li><a class="toctext" href="#HTTP-Utilities-1">HTTP Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> provides a pure Julia library for HTTP functionality.</p><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#HTTP-Types-1">HTTP Types</a></li><li><a href="index.html#HTTP-Utilities-1">HTTP Utilities</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><p>Note that the HTTP methods of POST, DELETE, PUT, etc. all follow the same format as <code>HTTP.get</code>, documented below.</p><pre><code class="language-none">HTTP.get
HTTP.send!
HTTP.Client
HTTP.Connection</code></pre><h2><a class="nav-anchor" id="HTTP-Types-1" href="#HTTP-Types-1">HTTP Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Request" href="#HTTP.Request"><code>HTTP.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request()
Request(method, uri, headers, body; options=RequestOptions())</code></pre><p>A type representing an http request. <code>method</code> can be provided as a string or <code>HTTP.GET</code> type enum. <code>uri</code> can be provided as an actual <code>HTTP.URI</code> or string. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> may be provided as string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>. <code>options</code> should be a <code>RequestOptions</code> type, see <code>?HTTP.RequestOptions</code> for details.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.method</code>: method for a request</p></li><li><p><code>HTTP.major</code>: major http version for a request</p></li><li><p><code>HTTP.minor</code>: minor http version for a request</p></li><li><p><code>HTTP.uri</code>: uri for a request</p></li><li><p><code>HTTP.headers</code>: headers for a request</p></li><li><p><code>HTTP.body</code>: body for a request as a <code>HTTP.FIFOBuffer</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/src/types.jl#L72-L88">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Response" href="#HTTP.Response"><code>HTTP.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response(status)
Response(status, headers, body)</code></pre><p>A type representing an http response. <code>status</code> represents the http status code for the response. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> can be provided as a string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.status</code>: status for a response</p></li><li><p><code>HTTP.statustext</code>: statustext for a response</p></li><li><p><code>HTTP.major</code>: major http version for a response</p></li><li><p><code>HTTP.minor</code>: minor http version for a response</p></li><li><p><code>HTTP.cookies</code>: cookies for a response, returned as a <code>Vector{HTTP.Cookie}</code></p></li><li><p><code>HTTP.headers</code>: headers for a response</p></li><li><p><code>HTTP.request</code>: the <code>HTTP.Request</code> that resulted in this response</p></li><li><p><code>HTTP.history</code>: history for a response if redirects were followed from an original request</p></li><li><p><code>HTTP.body</code>: body for a response as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a response body:</p><ul><li><p><code>string(r)</code>: consume the reponse body, returning it as a <code>String</code></p></li><li><p><code>HTTP.bytes(r)</code>: consume the response body, returning it as a <code>Vector{UInt8}</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/src/types.jl#L161-L182">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">`Cookie()`
`Cookie(; kwargs...)`
`Cookie(name, value; kwargs...)`</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/src/cookies.jl#L8-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URI" href="#HTTP.URI"><code>HTTP.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URI(host; userinfo=&quot;&quot;, path=&quot;&quot;, query=&quot;&quot;, fragment=&quot;&quot;, isconnect=false)
HTTP.URI(; scheme=&quot;&quot;, hostname=&quot;&quot;, port=&quot;&quot;, ...)
parse(HTTP.URI, str::String; isconnect=false)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>For efficiency, the internal representation is stored as a set of offsets and lengths to the various uri components. To access and return these components as strings, use the various accessor methods:</p><ul><li><p><code>HTTP.scheme</code>: returns the scheme (if any) associated with the uri</p></li><li><p><code>HTTP.userinfo</code>: returns the userinfo (if any) associated with the uri</p></li><li><p><code>HTTP.hostname</code>: returns the hostname only of the uri</p></li><li><p><code>HTTP.port</code>: returns the port of the uri; will return &quot;80&quot; or &quot;443&quot; by default if the scheme is &quot;http&quot; or &quot;https&quot;, respectively</p></li><li><p><code>HTTP.host</code>: returns the &quot;hostname:port&quot; combination</p></li><li><p><code>HTTP.path</code>: returns the path for a uri</p></li><li><p><code>HTTP.query</code>: returns the query for a uri</p></li><li><p><code>HTTP.fragment</code>: returns the fragment for a uri</p></li><li><p><code>HTTP.resource</code>: returns the path-query-fragment combination</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/src/uri.jl#L12-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.FIFOBuffer" href="#HTTP.FIFOBuffer"><code>HTTP.FIFOBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>FIFOBuffer</code> is a first-in, first-out, in-memory, async-friendly IO buffer type</p><p>Constructors:     <code>FIFOBuffer([max::Integer])</code>     <code>FIFOBuffer(string_or_bytes_vector)</code>     <code>FIFOBuffer(io::IO)</code></p><p><code>FIFOBuffer([max])</code>: creates a <code>FIFOBuffer</code> with a maximum size of <code>max</code>; this means that bytes can be written up until <code>max</code> number of bytes have been written (with none being read). At this point, the <code>FIFOBuffer</code> is full and will return 0 for all subsequent writes. If no <code>max</code> argument is given, then a default size of <code>typemax(Int32)^2</code> is used; this essentially allows all writes every time.</p><p>Reading is supported via <code>readavailable(f)</code> and <code>read(f, nb)</code>, which returns all or <code>nb</code> bytes, respectively, starting at the earliest bytes written.</p><p>You may call <code>String(f::FIFOBuffer)</code> to view the current contents in the buffer without consuming them.</p><p>A <code>FIFOBuffer</code> is built to be used asynchronously to allow buffered reading and writing. In particular, a <code>FIFOBuffer</code> detects if it is being read from/written to the main task, or asynchronously, and will behave slightly differently depending on which.</p><p>Specifically, when reading from a <code>FIFOBuffer</code>, if accessed from the main task, it will not block if there are no bytes available to read, instead returning an empty <code>UInt8[]</code>. If being read from asynchronously, however, reading will block until additional bytes have been written. An example of this in action is:</p><pre><code class="language-julia">f = HTTP.FIFOBuffer(5) # create a FIFOBuffer that will hold at most 5 bytes, currently empty
f2 = HTTP.FIFOBuffer(5) # a 2nd buffer that we&#39;ll write to asynchronously

# start an asynchronous writing task with the 2nd buffer
tsk = @async begin
    while !eof(f)
        write(f2, readavailable(f))
    end
end

# now write some bytes to the first buffer
# writing triggers our async task to wake up and read the bytes we just wrote
# leaving the first buffer empty again and blocking again until more bytes have been written
write(f, [0x01, 0x02, 0x03, 0x04, 0x05])

# we can see that `f2` now holds the bytes we wrote to `f`
String(readavailable(f2))

# our async task will continue until `f` is closed
close(f)

istaskdone(tsk) # true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/f030ab7be0971d309ced83565004d2cb205d160b/src/fifobuffer.jl#L1-L48">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Utilities-1" href="#HTTP-Utilities-1">HTTP Utilities</a></h2><pre><code class="language-none">HTTP.parse
HTTP.escape
HTTP.unescape
HTTP.userinfo
HTTP.splitpath
HTTP.isvalid
HTTP.sniff</code></pre><footer><hr/></footer></article></body></html>
