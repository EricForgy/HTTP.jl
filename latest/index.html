<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>HTTP.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#Server-1">Server</a></li><li><a class="toctext" href="#HTTP-Types-1">HTTP Types</a></li><li><a class="toctext" href="#HTTP-Utilities-1">HTTP Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> provides a pure Julia library for HTTP functionality.</p><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#Server-1">Server</a></li><li><a href="index.html#HTTP-Types-1">HTTP Types</a></li><li><a href="index.html#HTTP-Utilities-1">HTTP Utilities</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><p>Note that the HTTP methods of POST, DELETE, PUT, etc. all follow the same format as <code>HTTP.get</code>, documented below.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.get(uri) -&gt; Response
HTTP.get(client::HTTP.Client, uri) -&gt; Response</code></pre><p>Build and execute an http &quot;GET&quot; request. Query parameters can be passed via the <code>query</code> keyword argument as a <code>Dict</code>. Multiple query parameters with the same key can be passed like <code>Dict(&quot;key1&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;], &quot;key2&quot;=&gt;...)</code>. Returns a <code>Response</code> object that includes the resulting status code (<code>HTTP.status(r)</code> and <code>HTTP.statustext(r)</code>), response headers (<code>HTTP.headers(r)</code>), cookies (<code>HTTP.cookies(r)</code>), response history if redirects were involved (<code>HTTP.history(r)</code>), and response body (<code>HTTP.body(r)</code> or <code>take!(String, r)</code> or <code>take!(r)</code>).</p><p>The body or payload for a request can be given through the <code>body</code> keyword arugment. The body can be given as a <code>String</code>, <code>Vector{UInt8}</code>, <code>IO</code>, <code>HTTP.FIFOBuffer</code> or <code>Dict</code> argument type. See examples below for how to use an <code>HTTP.FIFOBuffer</code> for asynchronous streaming uploads. If the body is provided as a <code>Dict</code>, the request body will be uploaded using the multipart/form-data encoding. The key-value pairs in the Dict will constitute the name and value of each multipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an <code>IOStream</code> such as returned via <code>open(file)</code>, an <code>IOBuffer</code> for in-memory data, or even an <code>HTTP.FIFOBuffer</code>. For complete control over the multipart details, an <code>HTTP.Multipart</code> type is provided to support setting the <code>Content-Type</code>, <code>filename</code>, and <code>Content-Transfer-Encoding</code> if desired. See <code>?HTTP.Multipart</code> for more details.</p><p>Additional keyword arguments supported, include:</p><ul><li><p><code>headers::Dict{String,String}</code>: headers given as Dict to be sent with the request</p></li><li><p><code>body</code>: a request body can be given as a <code>String</code>, <code>Vector{UInt8}</code>, <code>IO</code>, <code>HTTP.FIFOBuffer</code> or <code>Dict</code>; see example below for how to utilize <code>HTTP.FIFOBuffer</code> for &quot;streaming&quot; request bodies; a <code>Dict</code> argument will be converted to a multipart form upload</p></li><li><p><code>stream::Bool=false</code>: enable response body streaming; depending on the response body size, the request will return before the full body has been received; as the response body is read, additional bytes will be recieved and put in the response body. Readers should read until <code>eof(response.body) == true</code>; see below for an example of response streaming</p></li><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li></ul><p>Simple request example:</p><pre><code class="language-julia">julia&gt; resp = HTTP.get(&quot;http://httpbin.org/ip&quot;)
HTTP.Response:
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 32
Access-Control-Allow-Credentials: true
Date: Fri, 06 Jan 2017 05:07:07 GMT
Content-Type: application/json
Access-Control-Allow-Origin: *
Server: nginx

{
  &quot;origin&quot;: &quot;65.130.216.45&quot;
}


julia&gt; string(resp)
&quot;{
  &quot;origin&quot;: &quot;65.130.216.45&quot;
}
&quot;</code></pre><p>Response streaming example:</p><pre><code class="language-julia">julia&gt; r = HTTP.get(&quot;http://httpbin.org/stream/100&quot;; stream=true)
HTTP.Response:
HTTP/1.1 200 OK
Content-Length: 0


julia&gt; body = HTTP.body(r)
HTTP.FIFOBuffer(0,1048576,0,1,1,UInt8[],Condition(Any[]),Task (runnable) @0x000000010d221690,false)

julia&gt; while true
    println(String(readavailable(body)))
    eof(body) &amp;&amp; break
end
{&quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;}, &quot;args&quot;: {}, &quot;id&quot;: 0, &quot;origin&quot;: &quot;65.130.216.45&quot;}
{&quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;}, &quot;args&quot;: {}, &quot;id&quot;: 1, &quot;origin&quot;: &quot;65.130.216.45&quot;}
{&quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;}, &quot;args&quot;: {}, &quot;id&quot;: 2, &quot;origin&quot;: &quot;65.130.216.45&quot;}
{&quot;url&quot;: &quot;http://httpbin.org/stream/100&quot;, &quot;headers&quot;: {&quot;Host&quot;: &quot;httpbin.org&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;User-Agent&quot;: &quot;HTTP.jl/0.0.0&quot;}, &quot;args&quot;: {}, &quot;id&quot;: 3, &quot;origin&quot;: &quot;65.130.216.45&quot;}
...</code></pre><p>Request streaming example:</p><pre><code class="language-julia"># create a FIFOBuffer for sending our request body
f = HTTP.FIFOBuffer()
# write initial data
write(f, &quot;hey&quot;)
# start an HTTP.post asynchronously
t = @async HTTP.post(&quot;http://httpbin.org/post&quot;; body=f)
write(f, &quot; there &quot;) # as we write to f, it triggers another chunk to be sent in our async request
write(f, &quot;sailor&quot;)
close(f) # setting eof on f causes the async request to send a final chunk and return the response

resp = wait(t) # get our response by getting the result of our asynchronous task</code></pre><pre><code class="language-none"></code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/client.jl#L336-L430">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.request" href="#HTTP.request"><code>HTTP.request</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.request([client::HTTP.Client,] req::HTTP.Request; stream::Bool=false, verbose=false)
HTTP.request([client,] method, uri; headers=HTTP.Headers(), body=&quot;&quot;, stream=false, verbose=false)</code></pre><p>Make an <code>HTTP.Request</code> to its associated host/uri. Set the keyword argument <code>stream=true</code> to enable response streaming, which will result in <code>HTTP.request</code> potentially returning before the entire response body has been received. If the response body buffer fills all the way up, it will block until its contents are read, freeing up additional space to write.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/client.jl#L75-L83">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Client" href="#HTTP.Client"><code>HTTP.Client</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.Client([logger::IO]; args...)</code></pre><p>A type to facilitate connections to remote hosts, send HTTP requests, and manage state between requests. Takes an optional <code>logger</code> IO argument where client activity is recorded (defaults to <code>STDOUT</code>). Additional keyword arguments can be passed that will get transmitted with each HTTP request:</p><ul><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/client.jl#L32-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Connection" href="#HTTP.Connection"><code>HTTP.Connection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.Connection</code></pre><p>Represents a persistent client connection to a remote host; only created when a server response includes the &quot;Connection: keep-alive&quot; header. An open and non-idle connection will be reused when sending subsequent requests to the same host.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/client.jl#L3-L9">source</a><br/></section><h2><a class="nav-anchor" id="Server-1" href="#Server-1">Server</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.serve" href="#HTTP.serve"><code>HTTP.serve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.serve([server,] host::IPAddr, port::Int; verbose::Bool=true, kwargs...)</code></pre><p>Start a server listening on the provided <code>host</code> and <code>port</code>. <code>verbose</code> indicates whether server activity should be logged. Optional keyword arguments allow construction of <code>Server</code> on the fly if the <code>server</code> argument isn&#39;t provided directly. See <code>?HTTP.Server</code> for more details on server construction and supported keyword arguments. By default, <code>HTTP.serve</code> aims to &quot;never die&quot;, catching and recovering from all internal errors. Two methods for stopping <code>HTTP.serve</code> include interrupting (ctrl/cmd+c) if blocking on the main task, or sending the kill signal via the server&#39;s in channel (<code>put!(server.in, HTTP.KILL)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/server.jl#L279-L288">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Server" href="#HTTP.Server"><code>HTTP.Server</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Server(handler, logger::IO=STDOUT; kwargs...)</code></pre><p>An http/https server. Supports listening on a <code>host</code> and <code>port</code> via the <code>HTTP.serve(server, host, port)</code> function. <code>handler</code> is a function of the form <code>f(::Request, ::Response) -&gt; Response</code>, i.e. it takes both a <code>Request</code> and pre-built <code>Response</code> objects as inputs and returns the, potentially modified, <code>Response</code>. <code>logger</code> indicates where logging output should be directed. When <code>HTTP.serve</code> is called, it aims to &quot;never die&quot;, catching and recovering from all internal errors. To forcefully stop, one can obviously kill the julia process, interrupt (ctrl/cmd+c) if main task, or send the kill signal over a server in channel like: <code>put!(server.in, HTTP.KILL)</code>.</p><p>Supported keyword arguments include:</p><ul><li><p><code>cert</code>: if https, the cert file to use, as passed to <code>TLS.SSLConfig(cert, key)</code></p></li><li><p><code>key</code>: if https, the key file to use, as passed to <code>TLS.SSLConfig(cert, key)</code></p></li><li><p><code>tlsconfig</code>: pass in an already-constructed <code>TLS.SSLConfig</code> instance</p></li><li><p><code>readtimeout</code>: how long a client connection will be left open without receiving any bytes</p></li><li><p><code>ratelimit</code>: a <code>Rational{Int}</code> of the form <code>5//1</code> indicating how many <code>messages//second</code> should be allowed per client IP address; requests exceeding the rate limit will be dropped</p></li><li><p><code>maxuri</code>: the maximum size in bytes that a request uri can be; default 8000</p></li><li><p><code>maxheader</code>: the maximum size in bytes that request headers can be; default 8kb</p></li><li><p><code>maxbody</code>: the maximum size in bytes that a request body can be; default 4gb</p></li><li><p><code>support100continue</code>: a <code>Bool</code> indicating whether <code>Expect: 100-continue</code> headers should be supported for delayed request body sending; default = <code>true</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/server.jl#L47-L67">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Types-1" href="#HTTP-Types-1">HTTP Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URI" href="#HTTP.URI"><code>HTTP.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URI(host; userinfo=&quot;&quot;, path=&quot;&quot;, query=&quot;&quot;, fragment=&quot;&quot;, isconnect=false)
HTTP.URI(; scheme=&quot;&quot;, hostname=&quot;&quot;, port=&quot;&quot;, ...)
parse(HTTP.URI, str::String; isconnect=false)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>For efficiency, the internal representation is stored as a set of offsets and lengths to the various uri components. To access and return these components as strings, use the various accessor methods:</p><ul><li><p><code>HTTP.scheme</code>: returns the scheme (if any) associated with the uri</p></li><li><p><code>HTTP.userinfo</code>: returns the userinfo (if any) associated with the uri</p></li><li><p><code>HTTP.hostname</code>: returns the hostname only of the uri</p></li><li><p><code>HTTP.port</code>: returns the port of the uri; will return &quot;80&quot; or &quot;443&quot; by default if the scheme is &quot;http&quot; or &quot;https&quot;, respectively</p></li><li><p><code>HTTP.host</code>: returns the &quot;hostname:port&quot; combination</p></li><li><p><code>HTTP.path</code>: returns the path for a uri</p></li><li><p><code>HTTP.query</code>: returns the query for a uri</p></li><li><p><code>HTTP.fragment</code>: returns the fragment for a uri</p></li><li><p><code>HTTP.resource</code>: returns the path-query-fragment combination</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/uri.jl#L12-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Request" href="#HTTP.Request"><code>HTTP.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request()
Request(method, uri, headers, body; options=RequestOptions())</code></pre><p>A type representing an http request. <code>method</code> can be provided as a string or <code>HTTP.GET</code> type enum. <code>uri</code> can be provided as an actual <code>HTTP.URI</code> or string. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> may be provided as string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>. <code>options</code> should be a <code>RequestOptions</code> type, see <code>?HTTP.RequestOptions</code> for details.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.method</code>: method for a request</p></li><li><p><code>HTTP.major</code>: major http version for a request</p></li><li><p><code>HTTP.minor</code>: minor http version for a request</p></li><li><p><code>HTTP.uri</code>: uri for a request</p></li><li><p><code>HTTP.headers</code>: headers for a request</p></li><li><p><code>HTTP.body</code>: body for a request as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a request body:</p><ul><li><p><code>take!(r)</code>: consume the request body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(take!(r))</code>: consume the request body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/types.jl#L190-L210">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RequestOptions" href="#HTTP.RequestOptions"><code>HTTP.RequestOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RequestOptions(; chunksize=, connecttimeout=, readtimeout=, tlsconfig=, maxredirects=, allowredirects=)</code></pre><p>A type to represent various http request options. Lives as a separate type so that options can be set at the <code>HTTP.Client</code> level to be applied to every request sent. Options include:</p><ul><li><p><code>chunksize::Int</code>: if a request body is larger than <code>chunksize</code>, the &quot;chunked-transfer&quot; http mechanism will be used and chunks will be sent no larger than <code>chunksize</code></p></li><li><p><code>connecttimeout::Float64</code>: sets a timeout on how long to wait when trying to connect to a remote host; default = 10.0 seconds</p></li><li><p><code>readtimeout::Float64</code>: sets a timeout on how long to wait when receiving a response from a remote host; default = 9.0 seconds</p></li><li><p><code>tlsconfig::TLS.SSLConfig</code>: a valid <code>TLS.SSLConfig</code> which will be used to initialize every https connection</p></li><li><p><code>maxredirects::Int</code>: the maximum number of redirects that will automatically be followed for an http request</p></li><li><p><code>allowredirects::Bool</code>: whether redirects should be allowed to be followed at all; default = <code>true</code></p></li><li><p><code>forwardheaders::Bool</code>: whether user-provided headers should be forwarded on redirects; default = <code>false</code></p></li><li><p><code>retries::Int</code>: # of times a request will be tried before throwing an error; default = 3</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/types.jl#L24-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Response" href="#HTTP.Response"><code>HTTP.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response(status)
Response(status, headers, body)</code></pre><p>A type representing an http response. <code>status</code> represents the http status code for the response. <code>headers</code> should be provided as a <code>Dict</code>. <code>body</code> can be provided as a string, byte vector, IO, or <code>HTTP.FIFOBuffer</code>.</p><p>Accessor methods include:</p><ul><li><p><code>HTTP.status</code>: status for a response</p></li><li><p><code>HTTP.statustext</code>: statustext for a response</p></li><li><p><code>HTTP.major</code>: major http version for a response</p></li><li><p><code>HTTP.minor</code>: minor http version for a response</p></li><li><p><code>HTTP.cookies</code>: cookies for a response, returned as a <code>Vector{HTTP.Cookie}</code></p></li><li><p><code>HTTP.headers</code>: headers for a response</p></li><li><p><code>HTTP.request</code>: the <code>HTTP.Request</code> that resulted in this response</p></li><li><p><code>HTTP.history</code>: history for a response if redirects were followed from an original request</p></li><li><p><code>HTTP.body</code>: body for a response as a <code>HTTP.FIFOBuffer</code></p></li></ul><p>Two convenience methods are provided for accessing a response body:</p><ul><li><p><code>take!(r)</code>: consume the response body, returning it as a <code>Vector{UInt8}</code></p></li><li><p><code>String(take!(r))</code>: consume the response body, returning it as a <code>String</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/types.jl#L279-L300">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/cookies.jl#L38-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.FIFOBuffer" href="#HTTP.FIFOBuffer"><code>HTTP.FIFOBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FIFOBuffer([max::Integer])
FIFOBuffer(string_or_bytes_vector)
FIFOBuffer(io::IO)</code></pre><p>A <code>FIFOBuffer</code> is a first-in, first-out, in-memory, async-friendly IO buffer type.</p><p><code>FIFOBuffer([max])</code>: creates a <code>FIFOBuffer</code> with a maximum size of <code>max</code>; this means that bytes can be written up until <code>max</code> number of bytes have been written (with none being read). At this point, the <code>FIFOBuffer</code> is full and will return 0 for all subsequent writes. If no <code>max</code> argument is given, then a default size of <code>typemax(Int32)^2</code> is used; this essentially allows all writes every time.</p><p>Reading is supported via <code>readavailable(f)</code> and <code>read(f, nb)</code>, which returns all or <code>nb</code> bytes, respectively, starting at the earliest bytes written.</p><p>You may call <code>String(f::FIFOBuffer)</code> to view the current contents in the buffer without consuming them.</p><p>A <code>FIFOBuffer</code> is built to be used asynchronously to allow buffered reading and writing. In particular, a <code>FIFOBuffer</code> detects if it is being read from/written to the main task, or asynchronously, and will behave slightly differently depending on which.</p><p>Specifically, when reading from a <code>FIFOBuffer</code>, if accessed from the main task, it will not block if there are no bytes available to read, instead returning an empty <code>UInt8[]</code>. If being read from asynchronously, however, reading will block until additional bytes have been written. An example of this in action is:</p><pre><code class="language-julia">f = HTTP.FIFOBuffer(5) # create a FIFOBuffer that will hold at most 5 bytes, currently empty
f2 = HTTP.FIFOBuffer(5) # a 2nd buffer that we&#39;ll write to asynchronously

# start an asynchronous writing task with the 2nd buffer
tsk = @async begin
    while !eof(f)
        write(f2, readavailable(f))
    end
end

# now write some bytes to the first buffer
# writing triggers our async task to wake up and read the bytes we just wrote
# leaving the first buffer empty again and blocking again until more bytes have been written
write(f, [0x01, 0x02, 0x03, 0x04, 0x05])

# we can see that `f2` now holds the bytes we wrote to `f`
String(readavailable(f2))

# our async task will continue until `f` is closed
close(f)

istaskdone(tsk) # true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/fifobuffer.jl#L1-L47">source</a><br/></section><h2><a class="nav-anchor" id="HTTP-Utilities-1" href="#HTTP-Utilities-1">HTTP Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.parse" href="#HTTP.parse"><code>HTTP.parse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.parse([HTTP.Request, HTTP.Response], str; kwargs...)</code></pre><p>Parse a <code>HTTP.Request</code> or <code>HTTP.Response</code> from a string. <code>str</code> must contain at least one full request or response (but may include more than one). Supported keyword arguments include:</p><ul><li><p><code>extra</code>: a <code>Ref{String}</code> that will be used to store any extra bytes beyond a full request or response</p></li><li><p><code>lenient</code>: whether the request/response parsing should allow additional characters</p></li><li><p><code>maxuri</code>: the maximum allowed size of a uri in a request</p></li><li><p><code>maxheader</code>: the maximum allowed size of headers</p></li><li><p><code>maxbody</code>: the maximum allowed size of a request or response body</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/parser.jl#L122-L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.escape" href="#HTTP.escape"><code>HTTP.escape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>percent-encode a string, dict, or pair for a uri</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/uri.jl#L157">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.unescape" href="#HTTP.unescape"><code>HTTP.unescape</code></a> — <span class="docstring-category">Function</span>.</div><div><p>unescape a percent-encoded uri/url</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/uri.jl#L191">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.splitpath" href="#HTTP.splitpath"><code>HTTP.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/uri.jl#L208-L211">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid" href="#Base.isvalid"><code>Base.isvalid</code></a> — <span class="docstring-category">Function</span>.</div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/uri.jl#L134">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/sniff.jl#L21-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.escapeHTML" href="#HTTP.escapeHTML"><code>HTTP.escapeHTML</code></a> — <span class="docstring-category">Function</span>.</div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/tree/ad7a8ceb50ff51dbd695b01350f5c8376b563291/src/utils.jl#L1-L5">source</a><br/></section><footer><hr/></footer></article></body></html>
